# 1장 개발환경

윈도우 드라이버를 처음 공부하는 독자들은 드라이버를 개발하기 위해 무엇을 준비해야 하는지에 대해 무엇보다 잘 알고 있어야 한다.

* 드라이버를 빌드하는 데 사용되는 개발툴과 지원하는 운영체제, 즉 윈도우 버전
* 드라이버를 디버깅하는 방법
* 드라이버를 작성하는 데 도움이 되는 사이트들

이렇게 세 가지를 알아야 한다.
마이크로소프트는 이 세 가지를 모두 DDK(WDK) 개발툴을 통해 개발자에게 제공하고 있다.
개발자는 단지 개발툴만 설치하면 빌드 환경, 디버깅 환경 그리고 참조할 도움말 정보를 모두 얻을 수 있다.
다만 아쉬운 점은 도움말 정보가 있지만 '아는 수준만큼만 정보가 보인다.'는 것이다.
나 역시 지금도 도움말을 참조해도 잘 이해되지 않는 내용이 많다.
이런 까닭에, 처음 드라이버 공부를 시작하는 독자들이 어느 정도로 어려움을 겪게 될지는 불 보듯 뻔하다.

윈도우 드라이버를 잘 작성하려면 무엇보다 윈도우 운영체제를 잘 이해해야 한다.
드라이버가 동작하는 주요 환경이 커널 레벨이라는 점을 감안하면, 윈도우 커널에 대해 더 많이 이해하면 할수록 분명 드라이버 개발이 쉽다.
이런 부분은 시중에서 구할 수 있는 서적들과 DDK(WDK)와 함께 제공되는 도움말 정보를 최대한 이해하면서 공부해야 한다.

다만 드라이버 개발에 있어서 개발툴(WDK)이 제공하는 샘플 소스와 디버깅 환경을 충분히 알고 있는 것은 가장 기본이 되는 전제이므로(또한 가장 중요한 정보다), 독자들은 개발툴을 자신의 것으로 잘 활용해야 한다.

## 1.1 디바이스 드라이버

윈도우에서 운용되는 디바이스 드라이버의 종류는 많다.
이들은 각각 사용될 유형에 따라서 그 종류를 구분할 수 있으며, 플러그 앤 플레이 환경을 사용하는 경우(PNP 드라이버)와 그렇지 않은 경우(레거시 드라이버)로 나눌 수도 있다.

### 1.1.1 기본 설명

디바이스 드라이버는 여러 가지 종류로 나뉜다.
|1|2|3|4|5|
|--|--|--|--|--|
|오디오 디바이스 드라이버|배터리 디바이스 드라이버|블루투스 디바이스 드라이버|디스플레이 디바이스 드라이버|HID 디바이스 드라이버|
|이미징 디바이스 드라이버|파일시스템 디바이스 드라이버|네트워크 디바이스 드라이버|프린터 디바이스 드라이버|센서 디바이스 드라이버|
|스마트카드 리더 디바이스 드라이버|스토리지 디바이스 드라이버|버스 디바이스 드라이버|포트 디바이스 드라이버|적외선 디바이스 드라이버|

꼭 그런 것은 아니지만 사용될 유형에 따라서 드라이버 개발 방법이 서로 다르기 때문에, 한 가지 유형의 드라이버를 개발해본 경험자라고 하더라도 다른 지식의 도움이 없이 이와 다른 유형의 드라이버를 작성하는 것은 어렵다.

### 1.1.2 레거시 드라이버

개발자들 사이에서 레거시 드라이버라는 용어는 여러 가지 의미로 사용되곤 한다.
어떤 이는 PNP 드라이버의 한 종류로서 실제 하드웨어가 존재하지 않는 상황에서 가상의 하드웨어를 하나 만든 뒤 이를 위한 드라이버를 만들게 되는데, 이것을 레거시 드라이버라고 한다.
또 다른 이는 하드웨어의 존재와 관련 없이 응용프로그램 혹은 서비스 프로그램이 원할 때 메모리에 상주하거나 메모리에서 제거되는 목적으로 사용하는 커널 레벨에서 동작하는 코드를 얻기 위해 드라이버를 만들기도 하는데, 이 드라이버를 지칭하기도 한다.
여기서는 후자의 개념으로 레거시 드라이버를 설명하고자 한다.
내가 보기에는 전자의 경우 가상의 하드웨어라 하더라도 윈도우가 볼 때는 실제 하드웨어가 존재하는 것과 같은 방식으로 드라이버를 운용하려 하기 때문에 엄격하게는 PNP 드라이버라고 부르는 것이 맞다고 생각되기 때문이다.

윈도우는 PNP 관리자와 Power 관리자를 운영하고 있으며, 이들의 영향력에서 벗어나는 드라이버가 바로 레거시 드라이버라고 볼 수 있다.
레거시 드라이버를 작성하는 개발자는 드라이버 코드 내에서 이와 같이 PNP, Power와 관련된 준비를 전혀 할 필요가 없다는 의미가 된다.

다음은 레거시 드라이버를 작성하는 개발자가 준비해둬야 하는 함수(콜백 함수) 리스트다.

* DriverEntry: 드라이버가 메모리에 상주할 때 호출되는 함수다. 유명한 응용프로그램인 "Hello World"의 입장에서 WinMain() 함수와 그 역할이 비슷하다고 보면 된다.
* DriverUnload: 드라이버가 메모리에 해제될 때 호출되는 콜백 함수다. 이 함수는 선택적이므로 가지지 않을 수도 있다. 이 함수를 선언하지 않으면 드라이버는 메모리에서 해제되지 않는다.
* IRP Dispatch: 외부에서 드라이버로 전달되는 명령어(IO Request Packet, IRP)를 받아들이는 진입점이다. 이곳으로는 열기, 닫기, 읽기, 쓰기 등의 파일 입출력 형식과 유사한 명령어가 전달되며, 드라이버 개발자는 이곳에서 명령어를 신속하게 다뤄야 한다. IRP Dispatch의 'Dispatch'라는 단어가 '신속하게 처리한다'는 의미를 담고 있듯이, 이곳에서 드라이버 개발자는 접수된 명령어의 피라미터 오류를 파악한 뒤, 적절한 명령어로 판단되면 빠른 처리를 보장해야 한다. 여기서 '빠른 처리'는 해당하는 명령어를 가능하면 빠리 완료하라는 의미로 사용되는 것이 아니라, 호출자에게 빨리 리턴하라는 것을 의미한다. 이것은 명령어가 접수만 된 상태로 호출자에게 돌아가는 것이 가능하다(STATUS_PENDING)는 의미가 된다.

### 1.1.3 PNP 드라이버

윈도우가 운영하는 PNP 관리자, Power 관리자와 함께 운용될 드라이버를 의미한다.
따라서 레거시 드라이버가 가지는 모든 콜백 함수 외에 별도의 콜백 함수가 추가로 정의돼야 한다.

다음은 PNP 드라이버를 작성하는 개발자가 준비해둬야 하는 함수 리스트다.

* DriverEntry, DriverUnload, IRP Dispatch: 이 내용은 레거시 드라이버의 경우와 같다.
* AddDevice: 디바이스 스택(발견된 하드웨어를 여러 PNP 드라이버들이 효과적으로 운영하기 위해 만든 자료구조)이 구성되자마자 호출되는 콜백 함수다. 드라이버 개발자는 이곳에서 디바이스 스택에 동참할 자신의 디바이스 오브젝트를 만들어서 디바이스 스택에 올려놓는 역할을 수행한다. DriverEntry 콜백함수는 드라이버가 멤리에 상주한다는 의미이지만, AddDevice 콕백 함수는 드라이버가 관여할 하드웨어가 발견됐다는 의미로 호출된다. 동일한 제조사의 하드웨어 2개를 PC에 연결하는 경우, 하드웨어가 2개라 하더라도 드라이버는 하나만 사용된다. 이런 경우 DrvierEntry 콜백 함수는 한 번 호출되지만 AddDevice 콜백 함수가 두 번 호출된다는 점을 기억하면 어렵지 않게 이해할 수 있다. 여기서 AddDevice 콜백 함수가 호출된 시기는 아직까지 하드웨어에 접근해도 좋다는 허가의 의미가 아니라는 점에 주의해야 한다. 하드웨어에 접근해도 되는 시기를 알려주는 방법은 이어지는 IRP_MJ_PNP 콜백 함수와 IRP_MJ_POWER 콜백 함수에 의해 결정된다.
* IRP_MJ_PNP: PNP 관리자가 전달하는 IRP를 처리하는 콜백 함수를 의미한다. PNP 관리자는 여러 가지 플러그 앤 플레이와 관련된 사건들이 발생할 때마다 이를 IRP에 담아서 드라이버에게 전달한다. 따라서 드라이버 개발자는 이곳에서 IRP에 담겨 있는 구체적인 사건의 의미를 파악해 행동해야 한다. 이런사건들은 2장에서 다룬다.
* IRP_MJ_POWER: POWER 관리자가 전달하는 IRP를 처리하는 콜백 함수를 의미한다. POWER 관리자는 전력공급과 관련된 사건들이 발생할 때마다 이를 IRP에 담아서 드라이버에게 전달한다. 따라서 드라이버 개발자는 이곳에서 IRP에 담겨 있는 구체적인 사건의 의미를 파악해 행동해야 한다. 이것들 또한 2장에서 살펴본다.


## 1.2 개발툴 설치

윈도우 드라이버를 개발하려면 개발툴을 설치해야 한다. 과거 윈도우3.1 시절부터 이와 같은 개발툴은 DDK라는 이름으로 공급돼 왔다. 
현재는 WDK라는 이름으로 바뀌어 공급되고 있다.
WDK 7 버전까지는 컴파일러가 함께 포함돼 배포됐기 때문에 개발자는 손쉽게 WDK가 제공하는 일종의 명령어 창을 열고 그곳에서 드라이버를 빌드할 수 있었지만, 최근 WDK는 컴파일러를 따로 포함하지 않고 있기 때문에 별도의 컴파일 환경을 구축해야 한다.
이것은 비주얼 스튜디오 2017을 함께 설치해야만 드라이버를 빌드할 수 있다는 의미다.
이책을 쓰고 있는 현재 WDK 10까지 배포된 상태다.

그런데, 최근까지도 개발자들 사이에서 비주얼 스튜디오 통합환경 속에서 드라이버 빌드가 잘 되지 않는 상황들에 대해서 이야기가 나오고 있다.
이에 나는 컴파일러와 링커가 모두 내장된 환경인 EWDK(엔터프라이즈 WDK)를 사용해서 드라이버를 빌드할 것이다.
드라이버를 쉽게 빌드할 수 있다는 장점을 가지고 있지만, 빌드에 사용되기 위한 모든 프로젝트는 프로젝트 파일을 가지고 있는 상태여야 한다는 단점이 있다.
이에 나는 실습 예제로 제공하는 모든 예제에 프로젝트 파일을 포함하도록 했다.
독자들은 EWDK를 웹 사이트를 통해 받아서 하드디스크 적당한 곳에 ISO 파일을 복사하고 가상 드라이버로 마운트만 하면 된다.

앞으로 특별한 언급이 없다면, 다음과 같은 방식으로 예제를 빌드할 것이다.

디바이스 드라이버 프로젝트는 EWDK 환경을 사용해서 빌드할 것이다.

응용 프로그램 프로젝트는 독자들이 원하는 개발툴을 사용하면 되지만, 여기서는 비주얼 스튜디오를 사용하도록 하겠다.

### 1.2.1 WDK

아래 표를 보면 WDK 8부터는 윈도우 XP용 드라이버를 빌드할 수 없음을 알 수 있다.
그렇기 때문에 윈도우XP까지 지원하는 드라이버를 빌드해야 하는 경우에는 WDK 7600을 설치해 컴파일해야 한다.

||윈도우XP|윈도우7|윈도우8|윈도우8.1|윈도우10
|--|--|--|--|--|--|
|WDK 7600|O|O|X|X|X|
|WDK 8|X|O|O|O|O|
|WDK 10|X|O|O|O|O|

### 1.2.2 WDM, KMDF 그리고 UMDF

윈도우에서 사용되는 디바이스 드라이버들은 그 유형에 따라서 개발하는 코딩 방식이 서로 다른 경우가 많다.
이와 같이 서로 다른 코딩 방식은 이 책의 3장에서부터 소개되는 유형별 드라이버들의 작성법을 보면 이해할 수 있다.
여기서는 보편적으로 많은 드라이버들이 취하고 있는 WDM 그리고 WDF에 관해 간단히 소개만 하려고 한다.

WDM과 WDF는 사실 같은 드라이버로 봐도 무방하다.
다만 WDM 형식을 사용하는 드라이버의 경우를 C 프로그래밍, WDF 형식을 사용하는 드라이버의 경우를 C++의 MFC 프로그래밍의 경우로 비유해서 이해하면 좋을 듯 하다.
그렇기 때문에 WDM 형식의 드라이버를 개발해본 경험자들은 WDF 형식의 드라이버를 개발해본 경험자들보다 운영체제 지식을 훨씬 더 잘 알고 있다고 여겨도 무방하다.

현업에서 드라이버를 개발하는 개발자 입장에서는 운영체제에 관해 더 깊이 있고 풍부한 지식을 습득하는 것이 중요하지만, 이에 못지 않게 빠른 개발도 중요하다.

드라이버 개발을 처음 해보는 독자들에게는 WDF 방식을 추천한다.
이 방식으로 개발하게 되면 독자들은 무엇 때문에 드라이버가 동작하는지를 확실하게 알지 못하더라도 빠른 개발을 할 수 있다는 장점을 가질 수 있다.
그리고 앞으로 WDK에서 제공하는 다양한 샘플 드라이버 소스 코드가 WDF 형식을 사용한다는 점에서도 도움이 된다.

![image](https://user-images.githubusercontent.com/52357235/180395014-c71c08ac-a32d-4127-8f2c-14ec976b1635.png)

WDM 형식의 드라이버를 개발하는 개발자들이 공통적으로 가져야 하는 아쉬움이라면, 사소한 것까지 드라이버 개발자가 알아서 모두 코딩해야 할 것 같은 느낌을 받는다는 점이다.
이것 때문에 실수가 잦을 수도 있으며, 무엇보다 마이크로소프트 인증프로그램(WHQL)을 통해 본인이 개발한 드라이버 코드를 인증 테스트하려면 WDF 형식의 드라이버를 개발한 개발자보다 더 많은 시간과 노력이 필요하다.
물론 시간을 많이 소요하지만 얻는 것이 많기 때문에, 중급 이상 개발자를 목표로 한다면 반드시 WDM 형식의 드라이버 작성법을 습득해야 한다.

위 그림을 보면, WDM 드라이버와 WDF 드라이버가 외관상으로는 동일하다는 것을 알 수 있다.
WDF 형식의 드라이버를 만드는 개발자는 WDF가 제공하는 프레임워크 내에 같이 연동될 중요한 이벤트 함수를 채우는 코드를 담당한다.
이런 이벤트 함수를 채웠다고 해서 자신이 드라이버의 모든 코드를 작성했다고 볼 수 없다는 점은 자명하다.

WDF 형식의 드라이버를 개발할 때, 해당하는 드라이버가 사용자 레벨에서 동작하려는 경우와 커널 레벨에서 동작하려는 경우에 따라서 개발 방법은 서로 달라진다.
사용자 레벨에서 동작하는 WDF 드라이버를 작성하려면, 개발자는 UMDF 형식의 드라이버 개발 방법을 습득해야 한다.
커널 레벨에서 동작하려는 WDF 드라이버를 작성하려면, 개발자는 KMDF 형식의 드라이버 개발 방법을 습득해야 한다.
이들 각각은 개발자의 고생을 조금이라도 덜어주고자 가능하면 동일한 자료구조들을 최대한 사용할 수 있도록 설계됐지만, 현실적으로 서로 다른 환경 아래에서 동작하기 때문에 이벤트 함수를 준비하는 방법이 서로 다르게 설계돼 있다.

KDMF를 지원하는 드라이버는 C 언어로 작성될 수 있지만, UMDF를 지원하는 드라이버는 C++ 언어로 작성돼야 한다.
단순하게 언어의 차이 때문이 아니라,  UMDF를 지원하는 드라이버는 마이크로소프트가 지원하는 COM(Component Object Model) 형식을 따라서 드라이버 코딩을 해야 하기 때문이다.
이런 이유로 인해 UMDF를 지원하는 드라이버를 개발하려면, 사전에 C++ 언어에 대한 지식을 습득한 후 C++ 언어로 표현하는 COM을 배워야 한다.
그런 다음, WDF가 설명하는 다양한 자료구조를 습득해야 하기 때문에 조금 까다로운 점이 뒤따른다.

UMDF를 지원하는 드라이버는 자신이 직접 하드웨어에 접근할 수 없다.
이것은 자신이 직접 하드웨어의 레지스터에 접근한다거나 하드웨어 메모리에 접근한다는 의미, 혹은 DMA 프로그래밍을 직접 할 수 없다는 의미가 된다.
그렇기 때문에 USB, 1394, I2C와 같은 버스에서 운용되는 하드웨어만 사용할 수 있는데, 이것은 운영체제가 이와 같은 버스에 한해 이들에 접근하는 버스 인터페이스를 위한 함수를 제공하기 때문이다.

이와 달리 커널 레벨에서 동작하는 KMDF를 지원하는 드라이버는 UMDF에서 사용하던 버스 인터페이스 함수도 사용할 수 있고 자신이 하드웨어에 직접 접근하는 것이 허용된다는 점에서 UMDF를 지원하는 것보다 장점이 될 수는 있지만, 커널 레벨에서 동작한다는 점 그 자체가 단점이 될 수 있다.
메모리 할당과 해제 작업을 포함해서 모든 작업들이 커널 레벨에서 이뤄지기 때문에, 약간의 실수만으로도 블루스크린이 발생하는 상황을 만들어낼 수 있다.

## 1.3 개발 시작 전 검토사항

드라이버를 개발하기 위한 지식을 습득했다고 하더라도 몇 가지 부수적으로 알아야 하는 검토사항이 있다.
드라이버를 동작시킬 운영체제는 어떤 것인지, 32비트와 64비트 가운데 어떤 환경에서 동작시킬 드라이버를 만들려고 하는 것인지 등이다.

이와 같은 내용들은 WHQL 인증 여부와도 관련이 있으며, 드라이버 코드를 작성할 때 32비트와 64비트 환경에서 사용될 자료형을 선택하는 문제와도 관련 있다.
또한 운영체제를 선택하는 것에 따라 어떤 WDK 버전을 사용해야 하는지를 결정해야 할 수도 있기 때문이다.

## 1.4 설치 파일

드라이버를 작성하면서 같이 작성돼야 하는 것이 INF 파일이다.
우리가 사는 현실 세계에서도 누군가가 학교, 직장에 무작정 찾아가서 '나 지금부터 이곳에 다닐 거야.'라고 말하면 학교와 직장의 사람들이 매우 난처해질 수밖에 없다.
그 이유는 다들 잘알고 있는 것과 같다.
우선적으로 사는곳, 이름, 학력 등 다니려고 하는 사람의 정보를 알아야 한다.
학교, 직장 같은 단체들은 제공받은 정보를 보고 다닐 수 있는지 없는지 여부를 판단한다.
INF 파일도 이와 같다.
운영체제 입장에서도 드라이버가 무슨 드라이버인지 최소한의 정보가 필요하다.
사용자의 컴퓨터에 하드웨어 장치가 연결되면 운영체제는 INF를 보고 어떤 드라이버를 연결해줘야 하는지 판단한다.
이런 정보를 기술하는 곳이 INF다.

INF는 섹션으로 구분해 드라이버에 대한 정보를 기술한다.
섹션은 '['과 ']'로 감싸서 구분한다.
섹션에는 이미 정해져 있는 예약된 이름의 섹션과 개발자 편의에 의해 개발자가 정하는 이름을 가진 섹션이 있다.
지금부터 드라이버를 개발하면서 작성해야 하는 필수 섹션에 대해 알아보자.

### 1.4.1 Version 섹션

윈도우9x/Me/2000이나 그 이상 버전의 운영체제에서 필요로 하는 섹션이다.
INF 파일이 어떤 포맷의 내용을 서술하게 되는지를 설명한다.
드라이버를 나타내는 아주 중요한 섹션이다.

''' INF
예제

'''
