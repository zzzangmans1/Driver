# 1장 개발환경

윈도우 드라이버를 처음 공부하는 독자들은 드라이버를 개발하기 위해 무엇을 준비해야 하는지에 대해 무엇보다 잘 알고 있어야 한다.

* 드라이버를 빌드하는 데 사용되는 개발툴과 지원하는 운영체제, 즉 윈도우 버전
* 드라이버를 디버깅하는 방법
* 드라이버를 작성하는 데 도움이 되는 사이트들

이렇게 세 가지를 알아야 한다.
마이크로소프트는 이 세 가지를 모두 DDK(WDK) 개발툴을 통해 개발자에게 제공하고 있다.
개발자는 단지 개발툴만 설치하면 빌드 환경, 디버깅 환경 그리고 참조할 도움말 정보를 모두 얻을 수 있다.
다만 아쉬운 점은 도움말 정보가 있지만 '아는 수준만큼만 정보가 보인다.'는 것이다.
나 역시 지금도 도움말을 참조해도 잘 이해되지 않는 내용이 많다.
이런 까닭에, 처음 드라이버 공부를 시작하는 독자들이 어느 정도로 어려움을 겪게 될지는 불 보듯 뻔하다.

윈도우 드라이버를 잘 작성하려면 무엇보다 윈도우 운영체제를 잘 이해해야 한다.
드라이버가 동작하는 주요 환경이 커널 레벨이라는 점을 감안하면, 윈도우 커널에 대해 더 많이 이해하면 할수록 분명 드라이버 개발이 쉽다.
이런 부분은 시중에서 구할 수 있는 서적들과 DDK(WDK)와 함께 제공되는 도움말 정보를 최대한 이해하면서 공부해야 한다.

다만 드라이버 개발에 있어서 개발툴(WDK)이 제공하는 샘플 소스와 디버깅 환경을 충분히 알고 있는 것은 가장 기본이 되는 전제이므로(또한 가장 중요한 정보다), 독자들은 개발툴을 자신의 것으로 잘 활용해야 한다.

## 1.1 디바이스 드라이버

윈도우에서 운용되는 디바이스 드라이버의 종류는 많다.
이들은 각각 사용될 유형에 따라서 그 종류를 구분할 수 있으며, 플러그 앤 플레이 환경을 사용하는 경우(PNP 드라이버)와 그렇지 않은 경우(레거시 드라이버)로 나눌 수도 있다.

### 1.1.1 기본 설명

디바이스 드라이버는 여러 가지 종류로 나뉜다.
|1|2|3|4|5|
|--|--|--|--|--|
|오디오 디바이스 드라이버|배터리 디바이스 드라이버|블루투스 디바이스 드라이버|디스플레이 디바이스 드라이버|HID 디바이스 드라이버|
|이미징 디바이스 드라이버|파일시스템 디바이스 드라이버|네트워크 디바이스 드라이버|프린터 디바이스 드라이버|센서 디바이스 드라이버|
|스마트카드 리더 디바이스 드라이버|스토리지 디바이스 드라이버|버스 디바이스 드라이버|포트 디바이스 드라이버|적외선 디바이스 드라이버|

꼭 그런 것은 아니지만 사용될 유형에 따라서 드라이버 개발 방법이 서로 다르기 때문에, 한 가지 유형의 드라이버를 개발해본 경험자라고 하더라도 다른 지식의 도움이 없이 이와 다른 유형의 드라이버를 작성하는 것은 어렵다.

### 1.1.2 레거시 드라이버

개발자들 사이에서 레거시 드라이버라는 용어는 여러 가지 의미로 사용되곤 한다.
어떤 이는 PNP 드라이버의 한 종류로서 실제 하드웨어가 존재하지 않는 상황에서 가상의 하드웨어를 하나 만든 뒤 이를 위한 드라이버를 만들게 되는데, 이것을 레거시 드라이버라고 한다.
또 다른 이는 하드웨어의 존재와 관련 없이 응용프로그램 혹은 서비스 프로그램이 원할 때 메모리에 상주하거나 메모리에서 제거되는 목적으로 사용하는 커널 레벨에서 동작하는 코드를 얻기 위해 드라이버를 만들기도 하는데, 이 드라이버를 지칭하기도 한다.
여기서는 후자의 개념으로 레거시 드라이버를 설명하고자 한다.
내가 보기에는 전자의 경우 가상의 하드웨어라 하더라도 윈도우가 볼 때는 실제 하드웨어가 존재하는 것과 같은 방식으로 드라이버를 운용하려 하기 때문에 엄격하게는 PNP 드라이버라고 부르는 것이 맞다고 생각되기 때문이다.

윈도우는 PNP 관리자와 Power 관리자를 운영하고 있으며, 이들의 영향력에서 벗어나는 드라이버가 바로 레거시 드라이버라고 볼 수 있다.
레거시 드라이버를 작성하는 개발자는 드라이버 코드 내에서 이와 같이 PNP, Power와 관련된 준비를 전혀 할 필요가 없다는 의미가 된다.

다음은 레거시 드라이버를 작성하는 개발자가 준비해둬야 하는 함수(콜백 함수) 리스트다.

* DriverEntry: 드라이버가 메모리에 상주할 때 호출되는 함수다. 유명한 응용프로그램인 "Hello World"의 입장에서 WinMain() 함수와 그 역할이 비슷하다고 보면 된다.
* DriverUnload: 드라이버가 메모리에 해제될 때 호출되는 콜백 함수다. 이 함수는 선택적이므로 가지지 않을 수도 있다. 이 함수를 선언하지 않으면 드라이버는 메모리에서 해제되지 않는다.
* IRP Dispatch: 외부에서 드라이버로 전달되는 명령어(IO Request Packet, IRP)를 받아들이는 진입점이다. 이곳으로는 열기, 닫기, 읽기, 쓰기 등의 파일 입출력 형식과 유사한 명령어가 전달되며, 드라이버 개발자는 이곳에서 명령어를 신속하게 다뤄야 한다. IRP Dispatch의 'Dispatch'라는 단어가 '신속하게 처리한다'는 의미를 담고 있듯이, 이곳에서 드라이버 개발자는 접수된 명령어의 피라미터 오류를 파악한 뒤, 적절한 명령어로 판단되면 빠른 처리를 보장해야 한다. 여기서 '빠른 처리'는 해당하는 명령어를 가능하면 빠리 완료하라는 의미로 사용되는 것이 아니라, 호출자에게 빨리 리턴하라는 것을 의미한다. 이것은 명령어가 접수만 된 상태로 호출자에게 돌아가는 것이 가능하다(STATUS_PENDING)는 의미가 된다.

### 1.1.3 PNP 드라이버

윈도우가 운영하는 PNP 관리자, Power 관리자와 함께 운용될 드라이버를 의미한다.
따라서 레거시 드라이버가 가지는 모든 콜백 함수 외에 별도의 콜백 함수가 추가로 정의돼야 한다.

다음은 PNP 드라이버를 작성하는 개발자가 준비해둬야 하는 함수 리스트다.

* DriverEntry, DriverUnload, IRP Dispatch: 이 내용은 레거시 드라이버의 경우와 같다.
* AddDevice: 디바이스 스택(발견된 하드웨어를 여러 PNP 드라이버들이 효과적으로 운영하기 위해 만든 자료구조)이 구성되자마자 호출되는 콜백 함수다. 드라이버 개발자는 이곳에서 디바이스 스택에 동참할 자신의 디바이스 오브젝트를 만들어서 디바이스 스택에 올려놓는 역할을 수행한다. DriverEntry 콜백함수는 드라이버가 멤리에 상주한다는 의미이지만, AddDevice 콕백 함수는 드라이버가 관여할 하드웨어가 발견됐다는 의미로 호출된다. 동일한 제조사의 하드웨어 2개를 PC에 연결하는 경우, 하드웨어가 2개라 하더라도 드라이버는 하나만 사용된다. 이런 경우 DrvierEntry 콜백 함수는 한 번 호출되지만 AddDevice 콜백 함수가 두 번 호출된다는 점을 기억하면 어렵지 않게 이해할 수 있다. 여기서 AddDevice 콜백 함수가 호출된 시기는 아직까지 하드웨어에 접근해도 좋다는 허가의 의미가 아니라는 점에 주의해야 한다. 하드웨어에 접근해도 되는 시기를 알려주는 방법은 이어지는 IRP_MJ_PNP 콜백 함수와 IRP_MJ_POWER 콜백 함수에 의해 결정된다.
* IRP_MJ_PNP: PNP 관리자가 전달하는 IRP를 처리하는 콜백 함수를 의미한다. PNP 관리자는 여러 가지 플러그 앤 플레이와 관련된 사건들이 발생할 때마다 이를 IRP에 담아서 드라이버에게 전달한다. 따라서 드라이버 개발자는 이곳에서 IRP에 담겨 있는 구체적인 사건의 의미를 파악해 행동해야 한다. 이런사건들은 2장에서 다룬다.
* IRP_MJ_POWER: POWER 관리자가 전달하는 IRP를 처리하는 콜백 함수를 의미한다. POWER 관리자는 전력공급과 관련된 사건들이 발생할 때마다 이를 IRP에 담아서 드라이버에게 전달한다. 따라서 드라이버 개발자는 이곳에서 IRP에 담겨 있는 구체적인 사건의 의미를 파악해 행동해야 한다. 이것들 또한 2장에서 살펴본다.


## 1.2 개발툴 설치

윈도우 드라이버를 개발하려면 개발툴을 설치해야 한다. 과거 윈도우3.1 시절부터 이와 같은 개발툴은 DDK라는 이름으로 공급돼 왔다. 
현재는 WDK라는 이름으로 바뀌어 공급되고 있다.
WDK 7 버전까지는 컴파일러가 함께 포함돼 배포됐기 때문에 개발자는 손쉽게 WDK가 제공하는 일종의 명령어 창을 열고 그곳에서 드라이버를 빌드할 수 있었지만, 최근 WDK는 컴파일러를 따로 포함하지 않고 있기 때문에 별도의 컴파일 환경을 구축해야 한다.
이것은 비주얼 스튜디오 2017을 함께 설치해야만 드라이버를 빌드할 수 있다는 의미다.
이책을 쓰고 있는 현재 WDK 10까지 배포된 상태다.

그런데, 최근까지도 개발자들 사이에서 비주얼 스튜디오 통합환경 속에서 드라이버 빌드가 잘 되지 않는 상황들에 대해서 이야기가 나오고 있다.
이에 나는 컴파일러와 링커가 모두 내장된 환경인 EWDK(엔터프라이즈 WDK)를 사용해서 드라이버를 빌드할 것이다.
드라이버를 쉽게 빌드할 수 있다는 장점을 가지고 있지만, 빌드에 사용되기 위한 모든 프로젝트는 프로젝트 파일을 가지고 있는 상태여야 한다는 단점이 있다.
이에 나는 실습 예제로 제공하는 모든 예제에 프로젝트 파일을 포함하도록 했다.
독자들은 EWDK를 웹 사이트를 통해 받아서 하드디스크 적당한 곳에 ISO 파일을 복사하고 가상 드라이버로 마운트만 하면 된다.

앞으로 특별한 언급이 없다면, 다음과 같은 방식으로 예제를 빌드할 것이다.

디바이스 드라이버 프로젝트는 EWDK 환경을 사용해서 빌드할 것이다.

응용 프로그램 프로젝트는 독자들이 원하는 개발툴을 사용하면 되지만, 여기서는 비주얼 스튜디오를 사용하도록 하겠다.

### 1.2.1 WDK

아래 표를 보면 WDK 8부터는 윈도우 XP용 드라이버를 빌드할 수 없음을 알 수 있다.
그렇기 때문에 윈도우XP까지 지원하는 드라이버를 빌드해야 하는 경우에는 WDK 7600을 설치해 컴파일해야 한다.

||윈도우XP|윈도우7|윈도우8|윈도우8.1|윈도우10
|--|--|--|--|--|--|
|WDK 7600|O|O|X|X|X|
|WDK 8|X|O|O|O|O|
|WDK 10|X|O|O|O|O|

### 1.2.2 WDM, KMDF 그리고 UMDF

윈도우에서 사용되는 디바이스 드라이버들은 그 유형에 따라서 개발하는 코딩 방식이 서로 다른 경우가 많다.
이와 같이 서로 다른 코딩 방식은 이 책의 3장에서부터 소개되는 유형별 드라이버들의 작성법을 보면 이해할 수 있다.
여기서는 보편적으로 많은 드라이버들이 취하고 있는 WDM 그리고 WDF에 관해 간단히 소개만 하려고 한다.

WDM과 WDF는 사실 같은 드라이버로 봐도 무방하다.
다만 WDM 형식을 사용하는 드라이버의 경우를 C 프로그래밍, WDF 형식을 사용하는 드라이버의 경우를 C++의 MFC 프로그래밍의 경우로 비유해서 이해하면 좋을 듯 하다.
그렇기 때문에 WDM 형식의 드라이버를 개발해본 경험자들은 WDF 형식의 드라이버를 개발해본 경험자들보다 운영체제 지식을 훨씬 더 잘 알고 있다고 여겨도 무방하다.

현업에서 드라이버를 개발하는 개발자 입장에서는 운영체제에 관해 더 깊이 있고 풍부한 지식을 습득하는 것이 중요하지만, 이에 못지 않게 빠른 개발도 중요하다.

드라이버 개발을 처음 해보는 독자들에게는 WDF 방식을 추천한다.
이 방식으로 개발하게 되면 독자들은 무엇 때문에 드라이버가 동작하는지를 확실하게 알지 못하더라도 빠른 개발을 할 수 있다는 장점을 가질 수 있다.
그리고 앞으로 WDK에서 제공하는 다양한 샘플 드라이버 소스 코드가 WDF 형식을 사용한다는 점에서도 도움이 된다.

![image](https://user-images.githubusercontent.com/52357235/180395014-c71c08ac-a32d-4127-8f2c-14ec976b1635.png)

WDM 형식의 드라이버를 개발하는 개발자들이 공통적으로 가져야 하는 아쉬움이라면, 사소한 것까지 드라이버 개발자가 알아서 모두 코딩해야 할 것 같은 느낌을 받는다는 점이다.
이것 때문에 실수가 잦을 수도 있으며, 무엇보다 마이크로소프트 인증프로그램(WHQL)을 통해 본인이 개발한 드라이버 코드를 인증 테스트하려면 WDF 형식의 드라이버를 개발한 개발자보다 더 많은 시간과 노력이 필요하다.
물론 시간을 많이 소요하지만 얻는 것이 많기 때문에, 중급 이상 개발자를 목표로 한다면 반드시 WDM 형식의 드라이버 작성법을 습득해야 한다.

위 그림을 보면, WDM 드라이버와 WDF 드라이버가 외관상으로는 동일하다는 것을 알 수 있다.
WDF 형식의 드라이버를 만드는 개발자는 WDF가 제공하는 프레임워크 내에 같이 연동될 중요한 이벤트 함수를 채우는 코드를 담당한다.
이런 이벤트 함수를 채웠다고 해서 자신이 드라이버의 모든 코드를 작성했다고 볼 수 없다는 점은 자명하다.

WDF 형식의 드라이버를 개발할 때, 해당하는 드라이버가 사용자 레벨에서 동작하려는 경우와 커널 레벨에서 동작하려는 경우에 따라서 개발 방법은 서로 달라진다.
사용자 레벨에서 동작하는 WDF 드라이버를 작성하려면, 개발자는 UMDF 형식의 드라이버 개발 방법을 습득해야 한다.
커널 레벨에서 동작하려는 WDF 드라이버를 작성하려면, 개발자는 KMDF 형식의 드라이버 개발 방법을 습득해야 한다.
이들 각각은 개발자의 고생을 조금이라도 덜어주고자 가능하면 동일한 자료구조들을 최대한 사용할 수 있도록 설계됐지만, 현실적으로 서로 다른 환경 아래에서 동작하기 때문에 이벤트 함수를 준비하는 방법이 서로 다르게 설계돼 있다.

KDMF를 지원하는 드라이버는 C 언어로 작성될 수 있지만, UMDF를 지원하는 드라이버는 C++ 언어로 작성돼야 한다.
단순하게 언어의 차이 때문이 아니라,  UMDF를 지원하는 드라이버는 마이크로소프트가 지원하는 COM(Component Object Model) 형식을 따라서 드라이버 코딩을 해야 하기 때문이다.
이런 이유로 인해 UMDF를 지원하는 드라이버를 개발하려면, 사전에 C++ 언어에 대한 지식을 습득한 후 C++ 언어로 표현하는 COM을 배워야 한다.
그런 다음, WDF가 설명하는 다양한 자료구조를 습득해야 하기 때문에 조금 까다로운 점이 뒤따른다.

UMDF를 지원하는 드라이버는 자신이 직접 하드웨어에 접근할 수 없다.
이것은 자신이 직접 하드웨어의 레지스터에 접근한다거나 하드웨어 메모리에 접근한다는 의미, 혹은 DMA 프로그래밍을 직접 할 수 없다는 의미가 된다.
그렇기 때문에 USB, 1394, I2C와 같은 버스에서 운용되는 하드웨어만 사용할 수 있는데, 이것은 운영체제가 이와 같은 버스에 한해 이들에 접근하는 버스 인터페이스를 위한 함수를 제공하기 때문이다.

이와 달리 커널 레벨에서 동작하는 KMDF를 지원하는 드라이버는 UMDF에서 사용하던 버스 인터페이스 함수도 사용할 수 있고 자신이 하드웨어에 직접 접근하는 것이 허용된다는 점에서 UMDF를 지원하는 것보다 장점이 될 수는 있지만, 커널 레벨에서 동작한다는 점 그 자체가 단점이 될 수 있다.
메모리 할당과 해제 작업을 포함해서 모든 작업들이 커널 레벨에서 이뤄지기 때문에, 약간의 실수만으로도 블루스크린이 발생하는 상황을 만들어낼 수 있다.

## 1.3 개발 시작 전 검토사항

드라이버를 개발하기 위한 지식을 습득했다고 하더라도 몇 가지 부수적으로 알아야 하는 검토사항이 있다.
드라이버를 동작시킬 운영체제는 어떤 것인지, 32비트와 64비트 가운데 어떤 환경에서 동작시킬 드라이버를 만들려고 하는 것인지 등이다.

이와 같은 내용들은 WHQL 인증 여부와도 관련이 있으며, 드라이버 코드를 작성할 때 32비트와 64비트 환경에서 사용될 자료형을 선택하는 문제와도 관련 있다.
또한 운영체제를 선택하는 것에 따라 어떤 WDK 버전을 사용해야 하는지를 결정해야 할 수도 있기 때문이다.

## 1.4 설치 파일

드라이버를 작성하면서 같이 작성돼야 하는 것이 INF 파일이다.
우리가 사는 현실 세계에서도 누군가가 학교, 직장에 무작정 찾아가서 '나 지금부터 이곳에 다닐 거야.'라고 말하면 학교와 직장의 사람들이 매우 난처해질 수밖에 없다.
그 이유는 다들 잘알고 있는 것과 같다.
우선적으로 사는곳, 이름, 학력 등 다니려고 하는 사람의 정보를 알아야 한다.
학교, 직장 같은 단체들은 제공받은 정보를 보고 다닐 수 있는지 없는지 여부를 판단한다.
INF 파일도 이와 같다.
운영체제 입장에서도 드라이버가 무슨 드라이버인지 최소한의 정보가 필요하다.
사용자의 컴퓨터에 하드웨어 장치가 연결되면 운영체제는 INF를 보고 어떤 드라이버를 연결해줘야 하는지 판단한다.
이런 정보를 기술하는 곳이 INF다.

INF는 섹션으로 구분해 드라이버에 대한 정보를 기술한다.
섹션은 '['과 ']'로 감싸서 구분한다.
섹션에는 이미 정해져 있는 예약된 이름의 섹션과 개발자 편의에 의해 개발자가 정하는 이름을 가진 섹션이 있다.
지금부터 드라이버를 개발하면서 작성해야 하는 필수 섹션에 대해 알아보자.

### 1.4.1 Version 섹션

윈도우9x/Me/2000이나 그 이상 버전의 운영체제에서 필요로 하는 섹션이다.
INF 파일이 어떤 포맷의 내용을 서술하게 되는지를 설명한다.
드라이버를 나타내는 아주 중요한 섹션이다.

**INF 파일 내용 예시1**

예제
[Version]
Signature="$WINDOWS NT$"
Class=%ClassName%
ClassGuid={78839F2E-1F69-44EB-AE7E-D6897F8C4F11}
Provider="%PROVIDER_STRING%"
DriverVer=01/20/2014, 19 .49 .39 .593
CatalogFile=SimpleHajeDrvier .cat
[Strings]
ClassName           ="EXAMPLEDRIVER"
PROVIDER_STRING     ="HajeSoft"

**Signature="signature-name"**
Signature는 드라이버가 어떤 운영체제를 지원하는지 나타낸다.
* Signature="$WINDOWS NT$": 윈도우NT 계열 운영체제만 지원하는 드라이버
* Signature="$WINDOWS 95$": 윈도우9X/Me 운영체제만 지원하는 드라이버
* Signature="$Chicago$": 윈도우 계열의 모든 운영체제를 지원하는 드라이버

**Class=class=name**
Class는 드라이버가 어떤 클래스를 지원하는 드라이버인지 나타낸다.
여기서 말하는 클래스는 장치 유형을 말한다.
예를 들어 USB, 마우스, 키보드, 저장장치 등을 시스템에서 정의한 클래스가 존재한다.
Class는 대응되는 ClassGuid가 있는데 ClassGuid에 대응되는 Class여야 한다.
단 운영체제에서 정의한 Class가 아닌 제조사가 새롭게 정의한 Class라면 Class Install32 섹션을 반드시 기술해야 한다.

**ClassGuid={nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn}**
Class와 대응되는 유일한 Class를 나타내는 GUID(Globally Unique Identifier)다.
예를 들어, Class=Printer라는 지시자 선언이 있다고 가정하자.
대부분 Printer라고 하면 프리터 드라이버와 관련된 내용이라고 생각한다.
하지만 어떤 사람의 이름일 수도 있다.
그 사람을 주변에서 'Hey! Mr Printer.'라고 부를 수도 있다는 의미다.
따라서 이것이 정확하게 어떤 의미로 사용되는지 부연 설명하는 것이 ClassGuid가 된다.

**Provider=%INF-creator%**
드라이버를 제공하는 공급자를 나타낸다.
다음의 에시처럼 제공자 이름을 바로 기술해도 되지만 앞뒤에 퍼센트(%)를 넣어 String 섹션에서 정의할 변수로 지정해 사용할 수 있다.

**DriverVer=mm/dd/yyyy[, x .x .y .z]**
윈도우 2000 이상부터 요구하는 지시자다. 
드라이버를 생성한 날짜와 버전을 기술한다.

**CatalogFile=filename.cat**
WHQL(Windows Hardware Quality Testing) 인증 테스트를 통과한 드라이버는 카탈로그 파일을 가지게 되는데, 인증을 받는 드라이버라면 반드시 기술돼야 하는 지시자다.
참고로 64비트 윈도우 운영체제에서 인증을 받지 않은 드라이버는 사용할 수 없다.

### 1.4.2 SoureceDisksNames 섹션

드라이버 설치에 사용할 파일들의 볼륨명이나 저장돼 있는 위치를 나타낼 때 사용되는 섹션이다.


원형
diskid = disk-description
diskid = disk-description , path
예제
[SourceDiskNames]
1= %Diskname%,,,""
2= %USBDiskName%,,,""
[Strings]
DiskName        ="Exam Driver Source Disk"
USBDiskName     ="Exam USB Driver Source Disk"

### 1.4.3 SourceDisksFiles 섹션

SourceDisksNames 섹션이 정의한 내용을 어떤 파일에 적용할 것인지 기술하는 섹션이다.

원형
filename=diskid[, [ subdir][, size]]
예제
[SourceDisksNames]
1=%Diskname%,,,""
2=%USBDiskname%,,,""
[SourceDisksFiles]
SimpleHajeDrvier.sys    =1
SimpleHajeUSBDriver.sys =2
[Strings]
DiskName        ="Exam Driver Source Disk"
USBDiskName     ="Exam USB Driver Source Disk"

### 1.4.4 DestinationDirs 섹션

드라이버 설치 과정 중 해당하는 장치에 사용될 드라이버가 어디로 복사될 것인지 기술하는 섹션이다.
복사될 위치는 dirid, 사용자 정의로 경로로 정의할 수 있다.

dirid는 시스템에서 이미 정의돼 있는 경로다.
사용하는 값의 위치는 다음과 같다.

* 10 - C:\Windows
* 11 - C:\Windows\System32
* 12 = C:\Windows\System32\Drivers
* 1 - 절대 경로

원형
[DefaultDestDir=dirid[,subdir]]
예제
[DestinationDirs]
HajeDriverFiles=12
HajeUSBDrvierFiles=12
[HajeDriverFiles]
SimpleHajeDriver.sys
[HajeUSBDriverFiles]
SimpleHajeUSBDriver.sys

이 섹션에서 주의할 것은 다음과 같다.
장치가 연결돼 드라이버를 설치할 때, 이 INF에서 기술한 모든 드라이버 파일이 지원하지 않는 장치라고 하더라도 복사될 것인가 아니면 해당하는 장치를 지원하는 드라이버 파일만 복사될 것인가를 고려해 이 섹션을 구성해야 한다.
위 예제는 2개의 제조사를 지원하는 드라이버라고 가정한 예제다.

### 1.4.5 Manufacturer 섹션

Manufacturer 섹션은 하나 또는 여러 장치의 제조사 장치를 지원하는 드라이버일 경우 사용하는 섹션으로, 필요에 따라 제조사, 아키텍처, 운영체제별로 어떤 장치를 지원할 것인지 정의할 수 있다.

원형
[manufacturer-identifier]
%strkey%=models-section-name |
%strkey%=models-section-name [, TargetOSVersion] [, TargetOSVersion]
예제
[Manufacturer]
%Manufacturer%    =Standard,NTx86,NTamd64
%ManufacturerUSB% =USBStandard,NTx86,NTamd64

위 보기를 보면 Standard, USBStandard가 Models 섹션이고 그 뒤에 오는 것이 운영체제 구분자다.
위 보기 예제는 운영체제 아키텍처만 구분하고 있다.
이 섹션에서 기술한 내용은 Models 섹션에서 구체적으로 각 제조사별로 지원하는 장치를 정의한다.
운영체제 아키텍처 말고도 운영체제 버전, 운영체제 타입(서버, 워크스테이션..) 등을 추가해 지원하는 운영체제를 좀 더 세밀하게 구분할 수 있다.

### 1.4.6 Stirngs 섹션
INF 파일 내에서 각 섹션마다 문자열 변수에 대치되는 실제 문자열을 Strings 섹션에 정의한다.

원형
[Strings] |
[Strings.LanguageID] ...
strkey1 = ["]some string["]
strkey2 = "string-with-leading-or-trailing-whitespace" |
          "very-long-multiline-string" |
          "string-with-semicolon" |
          "string-ending-in-backslash" |
          ""double-quoted-string-value""
예제
[Strings]
Manufacturer    ="HAJE Legacy"
ManufacturerUSB ="HAJE USB"
ClassName       ="EXAMPLEDRIVER"
DeviceDesc      ="HajeSoft SIMPLE DRIVER"

### 1.4.7 Models 섹션

Manufacturer 섹션에서 정의한 내용이 구체적으로 어떤 장치를 지원할 것인지 기술하는 섹션이다.
제조사별로 구분해야 하기 때문에 이 섹션은 딱히 이름이 정해져 있지 않다.
Manufacturer에서 기술한 내용이 Models 섹션이 된다.
Mdoels 섹션에서는 각각의 장치마다 어떻게 설치될 것인가를 정의하는 DDisntall 섹션을 기술한다.

원형
[models-section-name] |
[model-section-name.TargetOSVersion] (Windows XP and later versions of Windows)
device-description=install-section-name[, hw-id][,compatible-id...]
[device-description=install-section-name[, hw-id][,compatible-id...] ...

예제
[Standard.NTx86]
%DeviceDesc%=HAJE_SIMPLEDRIVER,SimpleHajeDrvier
[Standard.NTamd64]
%DeviceDesc%=HAJE_SIMPLEDRIVER,SimpleHajeDrvier
[USBStandard.NTx86]
%USB\VID_0403&PID_6001.DeviceDesc%=HAJE_SIMPLEUSBDRIVER, USB\VID_0403&PID_6001
%USB\VID_067B&PID_2303.DeviceDesc%=HAJE_SIMPLEUSBDRIVER, USB\VID_067B&PID_2303
[USBStandard.NTamd64]
%USB\VID_0403&PID_6001.DeviceDesc%=HAJE_SIMPLEUSBDRIVER, USB\VID_0403&PID_6001
%USB\VID_067B&PID_2303.DeviceDesc%=HAJE_SIMPLEUSBDRIVER, USB\VID_067B&PID_2303

위 보기의 예제를 보면 HAJE_SIMPLEUSBDRIVER, HAJE_SIMPLEDRIVER 2개가 DDInstall 섹션이고 그 뒤에 기술된 것이 장치를 구분하는 디바이스 ID다.

### 1.4.8 DDInstall 섹션

Models 섹션에서 정의한 install-Section이 DDInstall 섹션이다.
이 섹션에서는 설치할 내용을 구체적으로 설명한다.

#### 1.4.8.1 DDInstall 섹션 지시자
**CopyFile=@filename|file-list-section[,file-list-section]**
* DestinationDirs 섹션에서 정의한 파일 또는 섹션을 이곳에 기술한다. 어떤 드라이버가 설치될 것인가를 결정한다.

**CopyINF=filename1.inf[,filename2.inf]...**
* 드라이버 설치 과정 중에 복사돼야 하는 INF 파일이 있는 경우 사용한다. 단, 현재 INF 파일을 기술할 필요는 없다.

**Delfiles=file-list-section[,file-list-section]**
* 드라이버 설치 과정 중에 삭제해야 하는 파일이 있다면 사용된다. CopyFiles와 달리 파일 리스트가 정의된 섹션만 기술해야 한다.

**Renfiles=file-list-section[,file-list-section]**
* 드라이버 설치 과정에서 파일 이름이 변경돼야 하는 파일이 있는 경우 사용한다.
Delfiles와 마찬가지로 단일 파일명을 정의할 수 없고 섹션을 기술해야 한다.

**DelReg=del-registry-section[,del-registry-section]**
* 드라이버 설치 과정 중에 삭제해야 하는 레지스트리 키가 있다면 사용한다. 레지스트리에 대한 정보는 섹션에 정의해야 한다.

|축약어|Reg root string|
|--|--|
|HKCR|HKEY_CLASSES_ROOT|
|HKCU|HKEY_CURRENT_USER|
|HKLM|HKEY_LOCAL_MACHINE|
|HKU|HKEY_USERS|
|HKR|DDInstall</br> * Software Key</br>DDInstall.HW</br> * Hardwrae Key</br> DDInstall.Service</br> * Service Key|

위 표에서는 INF에서 사용되는 레지스트리 예약 이름이 실제 어떤 곳을 나타내는지를 정리해서 보여준다.
INF에서 사용되는 레지스트리 예약 이름은 각각 해당하는 레지스트리 키의 루트키를 나타낸다.

HKR은 다른 약어와는 다르게 루트가 아닌 특정 경로를 나타낸다.
또 DDinstlall 섹션 어디에서 사용됐는지에 따라 그 경로가 달라진다.

**LogConfig=log-config-section[,log-config-section]**
* 드라이버 설치 과정에서 드라이버가 사용할 입출력 자원 및 속성에 대해 정의할 때 사용한다. 구형 장치들이 사용한다.

**AddReg=add-registry-section[,add-registry-section]**
* 드라이버가 설치될 때 생성해야 하는 레지스트리 키가 있다면 기술한다. 장치가 연결됐을 때 어떻게 동작할 것인지 초기화하는 용도로 많이 사용한다.

#### 1.4.8.2 DDInstall.Service 섹션

DDInstall.Servcie 섹션은 드라이버에서 사용하는 서비스에 대한 내용을 정의한다.
하나 또는 그 이상의 내용을 정의할 수 있다.

원형</br> 
[install-section-name.Services] |</br>
[install-section-name.nt.Services] |</br> 
[install-section-name.ntx86.Services] |</br> 
[install-section-name.ntia64.Servcies] | (Windows XP and later versions of Windows)</br> 
[install-section-name.ntamd64.Services] (Windows XP and later versions of Windows) </br> 
예제 </br> 
[HAJE_SIMPLEDriVER.Services]</br> 
AddService = **SimpleHajeDrvier** ,0x00000002 ,Simple_Service_Inst</br> 
[HAJE_SIMPLEUSBDRIVER.Services]</br> 
AddService = simpleHajeUSBDriver ,0x00000002 ,Simple_USB_Service_Inst</br> 
[Simple_Service_Inst]</br> 
ServiceType    = 1</br> 
StartType      = 3</br> 
ErrorControl   = 1</br> 
ServiceBinary  = %12%\SimpleHajeDr.sys</br> 
LoadOrderGroup = Extended Base</br> 
[Simple_USB_Service_Inst]</br> 
Servicetype    = 1</br> 
StartType      = 3</br> 
ErrorControl   = 1</br> 
ServiceBinary  = %12%\SimpleHajeUSBDriver.sys</br> 
LoadOrderGroup = Extended Base</br> 

위 예제에서 HAJE_SIMPLEDRIVER.Services, HAJE_SIMPLEUSBDRIVER.Service 이 두 섹션을 보자

이 두 섹션 내용에서 AddService에 바로 보이는 SimpleHajeDriver, SimpleHajeUSBDriver 두 가지가 서비스의 이름이다.
서비스 키를 정의하는 과정에서 조심해야 할 상황이 있다.

서로 다른 하드웨어 ID를 가지는 장치를 시스템에 연결할 떄, 다음과 같은 두 가지 상황은 허용되지 않는다.
* 같은 서비스 이름을 사용하면서 실제 드라이버는 다른 경우
* 서로 다른 서비스 이름을 사용하면서 실제 드라이버 경로는 같은 경우

따라서 각각 서로 다른 서비스 이름을 사용해야 한다.

AddService=ServiceName,[flags],service-install-section
                       [,event-log-install-section[,[EventLogType]
                        [,Eventname]]]...]
                        
* AddService에 등록하는 섹션은 이 드라이버의 서비스 내용을 기술한다.

**ServiceType=type-code**
* 서비스의 종류를 나타내는 지시자다. 드라이버 같은 경우는 1로 사용한다. 서비스 종류를 나타내는 값은 다음과 같다.
 * 0x00000001: SERVICE_KERNEL_DRIVER
 * 0x00000010: SERVICE_WIN32_OWN_PROCESS
 * 0x00000020: SERVICE_WIN32_SHARE_PROCESS
 * 0x00000100: SERVCIE_FILE_SYSTEM_DRIVER
 
 **StartType=start-code**
 * 드라이버가 시작하는 시기를 결정하는 지시자다. USB와 같이 PNP를 지원하는 장치라면 0x3을 많이 사용한다. 0x03은 수동의 의미로, 드라이버를 메모리에 상주시키거나 메모리로부터 해제하는 시기가 평상시 아무 때나 발생할 수 있음을 말한다.
 
 **ServcieBinary=path-to-service**
 * 서비스에서 사용되는 드라이버 파일의 경로를 나타내는 지시자다. 이 지시자에 기술된 드라이버가 장치가 연결됐을 때 로드된다.
 
 **DelService=ServiceName[,[flags][,[EventLogType][,EventName]]]
 * 드라이버가 설치될 때 삭제해야 하는 서비스가 있을 때 사용한다. 플래그 값은 다음과 같이 두 가지가 사용될 수 있다.
  * 0x00000004: 서비스 이름과 연관된 이벤트 로그를 모두 제거한다.
  * 0x00000200: 서비스를 삭제하기 전에 서비스를 중지한다.
  
  
## 1.5 빌드

드라이버를 빌드하는 방법으로, WDK 7600까지는 콘솔을 이용했지만 WDK 8.0부터는 비주얼 스튜디오를 사용하도록 변경됐다.
그래서 현재는 윈도우XP를 지원하는지 여부에 따라 빌드하는 방법이 나눠진다.
만약 윈도우XP와 윈도우8을 지원해야 하는 드라이버라면, 윈도우XP는 콘솔로빌드해야 하고 윈도우8은 비주얼 스튜디오에서 빌드해야 할 것이다.
이번에는 빌드하는 법에 대해 간략하게 소개하려고 한다.
윈도우XP를 빋드하려면 WDK 7600이 설치돼 있어야 한다.
물론 윈도우 비스타 이전에 사용되던 DDK를 설치해도 상관은 없지만 WDK가 윈도우7까지 빌드가 가능하니 가능하면 WDK 7600을 설치하는 것이 좋다.
시작 메뉴에서 Windows Driver Kits 경로로 가면 Build Environments라는 폴더가 보인다.
이 폴더 안에 운영체제별로 빌드할 수 있는 컴파일러의 단축 아이콘이 있다.

### 1.5.1 WDK 7600 콘솔 빌드 환경

콘솔 창에서 빌드해야 하는 경우에는 빌드하기 위해 빌드할 대상의 소스가 포함된 경로에 다음의 파일들이 있어야 한다.
MAKEFILE 파일, Source 파일, 소스 파일들(C, C++, ASM, RC)
WDK가 제공하는 예제 경로에 들어가 있는 MAKEFILE 중 하나를 복사해서 사용해도 무방하다.
그렇기 때문에 개발자가 실제로 작성해야 하는 부분은 Sources 파일과 소스 파일들이다.

Sources 파일에는 크게 네 가지의 매크로를 필수로 정의해야 한다.
* TARGETNAME: 생성될 드라이버 파일의 이름이다.
* TARGETTYPE: 빌드할 대상의 유형을 정한다.
* SOURCES: 빌드할 때 필요한 소스 코드를 정의한다.
* TARGETLIBS: 소스 코드에서 사용한 헤더 파일의 라이브러리를 정의한다.

물론 이것 말고도 여러 가지 다양한 기능의 매크로가 존재한다.
콘솔 창에서 드라이버 소스와 MAKEFILE, Sources 파일이 들어 있는 경로로 이동한 뒤, Build 명령어를 실행하면 드라이버가 빌드되기 시작한다.

### 1.5.2 EWDK 빌드 환경

마이크로소프트는 응용프로그램을 빌드하는 데 사용하는 SDK와 드라이버를 빌드하는 데 사용하는 WDK를 모두 비주얼 스튜디오 환경 아래에서 통합적으로 사용하기 위해서 여러 가지 시도를 해왔다.
최근 비주얼 스튜디오 2017환경은 SDK, WDK를 모두 통합해 관리하고 있다.
이제 사용자는 두 가지 툴을 모두 설치하고 비주얼 스튜디오 환경 아래에서 응용 프로그램과 드라이버를 모두 빌드할 수 있다고 소개하고 있다.

하지만, 아직까지 원활하게 빌드가 잘 되지 않는 환경들이 많이 발견되고 있기 때문에, 여기서는 드라이버를 빌드할 때만 EWDK를 대신 사용하기로 한다.
응용프로그램을 빌드하는 경우는 비주얼 스튜디오를 그대로 사용하는 것으로 하곘다.

드라이버를 빌드하기 위해서는 EWDK만 있으면 되고, 응용프로그램을 빌드하기 위해서는 별도의 빌드 환경(비주얼 스튜디오)을 준비해야 한다.

마운트된 드라이브의 루트 디렉토리에 존재하는 "LaunchBuildEnv.cmd" 파일을 더블클릭한다.
이렇게 생성된 창에서 샘플 드라이버 프로젝트 파일을 선택하고 빌드를 진행하면 된다.

* 윈도우 64비트의 경우, 드라이버 테스트 시 유의사항
64비트 드라이버를 빌드하는 경우, 생성된 드라이버를 윈도우 64비트에서 사용할 때, MS WHQL 인증을 받지 않으면 정상적으로 설치되지 않는다.
따라서, 테스트용으로 드라이버를 설치하기 위해서 "BCDEDIT" 유틸리티를 사용해서 윈도우를 테스트 모드로 부팅해서 사용해야 한다.
위와 같은 설정이 돼 있는 윈도우 64비트 환경에서만 예제를 빌드해서 동작할 수 있다는 점을 꼭 기억하기 바란다.
이떄, 사용하는 "CMD.EXE" 프로그램은 관리자 권한으로 실행돼야 한다.

## 1.6 디버깅 툴

프로그램을 작성하거나 과정에서나 작성을 마치고 실행하는 과정에서 프로그램이 생각대로 동작하지 않거나 에러를 일으키는 경우가 있다.
이런 경우 디버거를 이용해 진단하는 것이 대부분이다.
드라이버의 경우도 이와 같이 디버깅이 가능하다.
커널 레벨에서 동작하는 드라이버를 디버깅하는 것은 애플리케이션을 디버깅할 때처럼 간단하지 않다.
여기서 드라이버를 디버깅할 때 사용하는 두 가지 툴을 소개한다.
**DebugView** 와 **WinDBG**다.

### 1.6.1 DebugView

DebugVeiw는 실시간으로 디버깅할 수 있는 툴이 아니다.
디버그 출력 관련 API로 출력한 문자열을 보여주는 툴이다.
이 프로그램은 응용프로그램과 드라이버에서 출력하고자 하는 디버그 메시지를 모두 출력할 수 있다.

이 툴은 주로 런타임 디버깅이 불가능한 환경에서 사용된다.
그래서 불루스크린이 발생할 때 함께 전달되는 버그 체크코드와 문제가 발생하는 시점 등을 보고 의심되는 코드 위치에 특정 변수의 값을 디버그 메시지로 출력하거나 특정 루틴이 호출됐는지 확인하는 용도로 로그를 출력하는 것이 이 툴의 목적이다.
이 방법은 런타임 디버깅이 아니므로, 이것을 사용해서 문제를 해결하기는 쉽지 않다.
그렇기 때문에 이 툴은 디버깅이 안 되는 환경에서 함수가 동작할 때 특정 변수 값을 매번 확인하기 위해 주로 많이 사용된다.

#### 1.6.1.1 DebugView 사용하기

DebugView를 실행해서 Capture Kernel 옵션을 체크해야만 커널에서 발생한 로그를 볼 수 있다.
드라이버가 커널에서 대부분 동작하기 때문이다.

![image](https://user-images.githubusercontent.com/52357235/180598316-82c5d0ab-4000-4f09-a627-1631feec11b5.png)

DebugView를 실행만 하고 가만히 둬도 여러 가지 발생하는 로그를 볼 수 있다.
이미 많은 다른 드라이버들이나 운영체제가 이런 로그를 출력하고 있기 때문이다.

#### 1.6.1.2 DebugView와 디버그 로그 출력조건

드라이버가 출력하고자 하는 디버그 로그를 보는 방법은 다음과 같다.
DebugView 프로그램을 이용하거나 이런 종류의 프로그램을 별도로 개발하거나, 그것도 아니면 WinDBG로 디버깅 PC와 타겟 PC를 연결한 뒤 WinDBG를 통해 출력된 로그를 확인하면 된다.

나는 주로 WinDBG를 사용한다 그런데 윈도우 비스타부터는 디버그 메시지 출력과 관련해서 이전 운영체제와 조금 다른 특징을 가진다.
디바이스 드라이버에서 사용하는 디버그 출력 함수 DbgPrint()는 이전 운영체제에서는 별다른 조치 없이 WinDBG에서 디버그 메시지 출력을 볼 수 있다.
하지만 윈도우 비스타부터는 보이지 않는다.
WinDBG를 구동한다 하더라도 디버그 메시지 출력을 볼 수 없다는 의미다.
그런데 재미있는 것은 이런 상태에서 타겟 PC상에 DbgView 프로그램을 실행하면, DbgView 프로그램과 WinDBG가 동시에 디버그 메시지를 출력하기 시작하는 사실이다.
분명 DbgView 프로그램이 무엇인가를 수행해야만 디버그 메시지가 출력된다는 뜻이다.
이것과 관련 있는 부분은 윈도우 비스타부터 제공되는 디버그 메시지와 관련된 심볼에서 그 해답을 찾을 수 있다.

윈도우는 Kd_Win2000_Mask 심볼과 Kd_Default_Mask 심볼을 제공한다.
Kd_Default_Mask 심볼은 여러 개의 심볼 중 하나의 조건에서 사용되는 위치정보를 담는다.

윈도우는 여러 개의 Kd_XXX_Mask 심볼을 제공하고 있다.

Kd_Win2000_Mask 값은 평상시 0을 가진다.
이 값이 0이면 드라이버가 호출하는 DbgPrint() 함수가 정상적으로 로그를 출력하지 않는다.
DbgView 프로그램이 실행되면, 이 프로그램은 이 메모리의 값을 1로 바꾼다.
1은 TRUE의 의미로 사용된다.
이렇게 함으로써 DbgPrint() 함수를 사용하는 모든 출력이 가능해진다.
WinDBG는 이 값을 변경하지 않는다.
따라서 별도의 변경이 없으면 드라이버가 사용하는 DbgPrint() 함수는 무의미한 결과를 가져오게 된다.

드라이버는 DbgPrintEx() 함수를 사용할 수도 있다. 
이 함수는 ComponentId와 Level을 디버그 로그와 함께 파라미터로 사용해야 한다.

``` C
// DbgPrintEx 함수 프로토타입
ULONG DbgPrintEx(
          IN ULONG ComponentId,
          IN ULONG Level,
          IN PCHAR Format,
          . . . . [arguments]
          );
```

위 보그를 보면, ComponentId와 Level 값이 보인다.
ComponentId 값은 디버그 출력을 할 드라이버의 종류를 규정한다.
Level 값은 0부터 31까지의 값을 사용하고, 이들은 각각 비트맵의 비트에 해당한다.
Level 0은 'Error' 조건을 의미하도록 예약돼 있다. 
예를 들어, 다음의 문장을 보자

``` C
DbgPrintEx(DPFLTR_DEFAULT_ID, 0, "Hello");
```

이 문장은 Kd_Default_Mask 심볼을 참고해서 0번 비트의 값이 TRUE이면 "Hello" 메시지를 출력하라는 뜻이다.
따라서 이 함수의 결과를 WinDBG에서 보고 싶다면, 반드시 Kd_Default_Mask의 값 중 0번 비트의 값이 1이어야 한다.

평상시 WinDBG만 구동될 때 이런 Mask의 값은 모두 0을 가진다.
따라서 DbgPrintEx() 함수를 사용하는 모든 로그 출력도 허용되지 않는다.
DbgView 프로그램이 실행되면, 이 프로그램은 이 값을 모두 0xFFFFFFFF 값으로 바꿔버린다.
결국 모든 조건의 디버그 메시지를 출력하도록 변경하는 것이다.

결론적으로 DbgView 프로그램을 사용하지 않는 조건에서, 디버그 메시지를 보고 싶다면 Kd_XXX_Mask 심볼을 사용해서 해당하는 값을 적당한 값으로 변경해야 한다.

Kd_Win2000_Mask의 값을 0에서 1로 변경하면, DbgPrint() 함수를 사용하는 모든 출력이 화면에 나타난다.
이런 경우 우리가 출력하고자 하는 내용만 보기 곤란하며, 다른 수많은 드라이버들이 출력하는 내용들이 함께 나타난다.

따라서 드라이버 개발자는 DbgPrint() 함수보다는 DbgPrintEx() 함수를 사용해서 조건을 명시하는 것이 좋다.
이런 조건값은 0번, 1번, 2번 그리고 3번 비트가 예약돼 있으므로 4부터 31 사이의 값을 사용하는 것이 현명하다.
그런 다음, 적당하게 WinDBG 상태에서 해당하는 심볼의 마스크 값을 변경하면 원하는 디버그 메시지 출력만 가능하게 된다.

### WinDBG

WinDBG는 WDK를 다운로드해 설치하면 자동으로 같이 설치되는 디버깅 툴이다.
우리가 비주얼 스튜디오에서 일반 콘솔, C++ 프로그램을 작성할 때 실시간으로 디버깅이 가능하다.

WinDBG도 마찬가지로 실시간 디버깅이 가능하다.
WinDBG도 응용프로그램을 디버깅할 수 있지만, 응용프로그래밍 디버깅 환경은 비주얼 스튜디오 통합 환경을 주로 사용하는 것이 일반적이다.
커널 레벨에서 동작하는 드라이버를 디버깅하는 용도와 블루스크린으로 인해 생성되는 덤프 파일을 분석하는 용도로 WinDBG를 사용한다.
WinDBG를 사용하는 디버깅 환경 설정은 조금 까다롭다.

드라이버 디버깅을 하기 위해서는 두 대의 PC가 필요하다.
하나는 타겟 PC(Debuggee), 다른 하나는 디버깅 PC(Host, Debugger)다.

두 PC의 디버깅 환경을 구축하기 위해서는 서로 연결돼야 하는데, PC를 연결하는 수단에는 IEEE 1394, 시리얼, USB, 네트워크가 있다.

이 중에서 IEEE 1394가 가장 빠르고 네트워크, USB, 시리얼의 순서를 가진다.
여기서 느리다, 빠르다를 말하는 것은 중단점이 걸렸을 때 반응이 나타나는 시기, 트레이스 등을 수행할 때 반응하는 시기, 지역변수 등의 내용을 확인할 때 반응하는 시기 등을 기준으로 한다.
최근 PC에서는 IEEE 1394, 시리얼은 거의 탑재돼 나오지 않기 때문에 따로 IEEE 1394를 사용하기 위해서는 이를 위한 PCI 카드를 구매해야 한다.
USB도 마찬가지로 USB 케이블로 연결된다고 해서 디버깅이 되는 것은 아니며, 디버깅 전용 장치가 있어야 한다.

현실적으로 네트워크 디버깅 환경을 사용하는 편이 가장 유리할 것으로 보인다.
다만, 타겟 PC에 부착된 네트워크 카드가 보편적으로 많이 알려진 카드여야 한다는 문제가 있지만, 거의 대부분 컴퓨터 메인보드에 실장돼 나오는 온보드용 이더넷카드는 여기에 해당하므로 크게 걱정할 필요는 없다.

#### 1.6.2.1 타겟 PC 설정

커널 디버깅을 위해 인터넷에서 타겟 PC 설정 방법을 찾아보면, 콘솔 창에서 설정하는 것이 대다수다.
여기서는 간단하게 키보드에서 '**윈도우 + R**'키를 누르고, 실행 창에서 Msconfig 명령을 실행하거나 **제어판**에서 **관리도구 시스템 구성**을 실행시키면 된다.
**부팅** 탭에서 **고급 옵션**을 클릭하면 디버깅 관련 옵션이 나온다.

그런데 이더넷 연결을 위한 PC 설정은 여기에서 할 수가 없다.

Bcdedit 프로그램은 BCD(Boot Config Data)를 변경하는 유틸리티로서, 마이크로소프트에서 제공하고 있는 관리자 권한의 툴이다.

BCDEDIT /dbgsettings net
          hostip:xx.xx.xx.xx : 디버깅 PC의 IP 주소
          port: xxxxx : 디버깅 PC와 연결하려는 포트번호(임의)
          key:xx.xx.xx.xx : 디버깅 PC와 연결할 때 사용하는 키값(임의)
          
위 보기를 보면, 이더넷을 통해서 디버깅 PC와 타겟 PC가 연결하려는 경우, 어떤 값을 파라미터로 사용해서 타겟 PC의 연결준비 과정에 사용하는지를 설명하고 있다.

독자들의 여건에 따라서 타겟 PC를 설정하는 방법은 선택적이다.
하지만 윈도우7 이하의 운영체제를 디버깅하려는 타겟 PC로 사용하려면 네트워크 디버깅은 잘 되지 않는다.
타겟 PC가 윈도우8.0 이상인 경우에만 이더넷 연결을 통해서 타겟 PC 설정을 하는 것을 권장한다.

1394, USB 케이블, 이더넷 등의 연결이 어려운 독자들은 메모리 덤프 파일을 사용해서 WinDBG를 실습해보는 것도 좋다.
BSOD(Blue Screen Of Death)가 발생하면 설정 상태에 따라서, 윈도우는 메모리 덤프 파일을 생성한다.
WinDBG 프로그램은 이와 같은 메모리 덤프 파일을 열 수 있다.
열기 작업만으로도 1394, USB 케이블, 이더넷을 통해 타겟 PC와 디버깅 PC가 연결된 것과 유사한 환경을 경험해볼 수 있다.
다만, 메모리 덤프 파일은 정적 이미지이기 때문에 WinDBG 사용자는 트레이스, 중단점 설정 등의 작업이 불가능하다.
1.6.2.3 절에서 이와 같은 덤프 파일을 생성하는 작업을 설명하겠다.

#### 1.6.2.2 디버깅 PC 설정

디버깅 PC는 WinDBG가 설치돼 있는 환경을 말한다.
WDK를 설치했다면 **시작 프로그램**을 선택해서 Debugging Tools for Windows(x86)을 볼 수 있다.
여기서 WinDBG.exe를 실행하면 된다.

먼저 심볼 설정을 해야 한다.
심볼이 없으면 디버깅하는 도중에 오류가 발생하거나, 운영체제가 준비한 다양한 정보를 볼 수 없다.
심볼이 없는 상태는 마치 지도없이 사막에서 오아시스를 찾는 상황에 비유할 수 있다.

심볼 폴더를 준비해야 하는데, 이것은 크게 두 가지로 나뉜다.
하나는 마이크로소프트가 다운로드해주는 운영체제를 위한 심볼을 저장하는 폴더이고, 다른 하나는 독자들이 만드는 드라이버 바이너리와 함께 생성되는 심볼을 저장하는 폴더다.

심볼 이름을 정하는 방법은 독자들이 나름대로 정할 수 있다.
여기서는 간단히 따라해 볼 수 있도록 내 환경을 예로 들어 설명해보려고 한다.
C 드라이브 루트 디렉터리에 'C:\SYM' 폴더를 만든다.
이곳은 앞으로 WinDBG가 참조할 모든 심볼이 들어 있는 폴더가 될 것이다.

'C:\SYM' 폴더 아래에 또 다른 하위 폴더 'WebSym'을 만든다.
이것은 WinDBG가 타겟 PC와 연결됐을 때 인터넷을 통해 다운로드할 타겟 PC의 윈도우를 위한 심볼 파일들이 보관될 경로다.

결곡 'C:\SYM' 폴더와 'C:\SYM\WebSym' 폴더를 만든 결과가 됐다.
이후 심볼 설정 메뉴를 통해 심볼 설정 내용을 입력한다.
srv`*` '''.`*` 에서 별표와 별표 사이에 인터넷을 통해 다운로드할 운영체제 심볼이 저장될 경로명을 넣는다.

'C:\sym;srv`*` C:\Sym\WebSym`*`http://msdl.mircrosoft.com/download/symbols'라고 입력하고 OK를 클릭한다.
그럼 심볼 설정이 완료된다.
이제 타겟 PC와 연결하자.

다시 File 메뉴로 돌아가서, Kernel Debug를 선택하면 창이 하나 나온다.
타겟 PC에서의 설정과 동일하게 설정한다.

설정하고 확인 버튼을 클릭하면 명령어 창이 나온다.
모든 설정이 끝나면, 디버깅 PC는 연결을 기다리는 상태가 된다.
연결할 타겟 PC를 재부팅한다.
재부팅할 때 운영체제 선택 메뉴에서 **디버깅 가능한 웅영체제 모드**를 선택해 부팅한다.
부팅되는 도중 혹은 부팅 이후에 디버깅 PC에서 **Ctrl + Pause(Break)** 키를 누르거나 Debug 메뉴에서 Break를 누르면 타겟 PC가 멈추게 된다.

Break 키를 누르면, 아랫 부분에 있는 프롬포트(kd>)는 새로운 입력을 받을 수 있는 상태가 된다.

WinDBG에서는 도움말(F1) 버튼을 클릭해서 사용할 명령어들에 대한 설명을 확인하고 간단한 사용법을 익힐 수 있다.

#### 1.6.2.3 메모리 덤프 파일을 통한 WinDBG 연결하기

메모리 덤프 파일을 생성하기 위해서는 설정 상태를 우선 확인 해봐야 한다.
메모리 덤프 파일을 위해서는 윈도우에 치명적인 오류가 발생한 것처럼 만들어야 한다.

이하 생략

