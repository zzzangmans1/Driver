# 1장 개발환경

윈도우 드라이버를 처음 공부하는 독자들은 드라이버를 개발하기 위해 무엇을 준비해야 하는지에 대해 무엇보다 잘 알고 있어야 한다.

* 드라이버를 빌드하는 데 사용되는 개발툴과 지원하는 운영체제, 즉 윈도우 버전
* 드라이버를 디버깅하는 방법
* 드라이버를 작성하는 데 도움이 되는 사이트들

이렇게 세 가지를 알아야 한다.
마이크로소프트는 이 세 가지를 모두 DDK(WDK) 개발툴을 통해 개발자에게 제공하고 있다.
개발자는 단지 개발툴만 설치하면 빌드 환경, 디버깅 환경 그리고 참조할 도움말 정보를 모두 얻을 수 있다.
다만 아쉬운 점은 도움말 정보가 있지만 '아는 수준만큼만 정보가 보인다.'는 것이다.
나 역시 지금도 도움말을 참조해도 잘 이해되지 않는 내용이 많다.
이런 까닭에, 처음 드라이버 공부를 시작하는 독자들이 어느 정도로 어려움을 겪게 될지는 불 보듯 뻔하다.

윈도우 드라이버를 잘 작성하려면 무엇보다 윈도우 운영체제를 잘 이해해야 한다.
드라이버가 동작하는 주요 환경이 커널 레벨이라는 점을 감안하면, 윈도우 커널에 대해 더 많이 이해하면 할수록 분명 드라이버 개발이 쉽다.
이런 부분은 시중에서 구할 수 있는 서적들과 DDK(WDK)와 함께 제공되는 도움말 정보를 최대한 이해하면서 공부해야 한다.

다만 드라이버 개발에 있어서 개발툴(WDK)이 제공하는 샘플 소스와 디버깅 환경을 충분히 알고 있는 것은 가장 기본이 되는 전제이므로(또한 가장 중요한 정보다), 독자들은 개발툴을 자신의 것으로 잘 활용해야 한다.

## 1.1 디바이스 드라이버

윈도우에서 운용되는 디바이스 드라이버의 종류는 많다.
이들은 각각 사용될 유형에 따라서 그 종류를 구분할 수 있으며, 플러그 앤 플레이 환경을 사용하는 경우(PNP 드라이버)와 그렇지 않은 경우(레거시 드라이버)로 나눌 수도 있다.

### 1.1.1 기본 설명

디바이스 드라이버는 여러 가지 종류로 나뉜다.
|1|2|3|4|5|
|--|--|--|--|--|
|오디오 디바이스 드라이버|배터리 디바이스 드라이버|블루투스 디바이스 드라이버|디스플레이 디바이스 드라이버|HID 디바이스 드라이버|
|이미징 디바이스 드라이버|파일시스템 디바이스 드라이버|네트워크 디바이스 드라이버|프린터 디바이스 드라이버|센서 디바이스 드라이버|
|스마트카드 리더 디바이스 드라이버|스토리지 디바이스 드라이버|버스 디바이스 드라이버|포트 디바이스 드라이버|적외선 디바이스 드라이버|

꼭 그런 것은 아니지만 사용될 유형에 따라서 드라이버 개발 방법이 서로 다르기 때문에, 한 가지 유형의 드라이버를 개발해본 경험자라고 하더라도 다른 지식의 도움이 없이 이와 다른 유형의 드라이버를 작성하는 것은 어렵다.

### 1.1.2 레거시 드라이버

개발자들 사이에서 레거시 드라이버라는 용어는 여러 가지 의미로 사용되곤 한다.
어떤 이는 PNP 드라이버의 한 종류로서 실제 하드웨어가 존재하지 않는 상황에서 가상의 하드웨어를 하나 만든 뒤 이를 위한 드라이버를 만들게 되는데, 이것을 레거시 드라이버라고 한다.
또 다른 이는 하드웨어의 존재와 관련 없이 응용프로그램 혹은 서비스 프로그램이 원할 때 메모리에 상주하거나 메모리에서 제거되는 목적으로 사용하는 커널 레벨에서 동작하는 코드를 얻기 위해 드라이버를 만들기도 하는데, 이 드라이버를 지칭하기도 한다.
여기서는 후자의 개념으로 레거시 드라이버를 설명하고자 한다.
내가 보기에는 전자의 경우 가상의 하드웨어라 하더라도 윈도우가 볼 때는 실제 하드웨어가 존재하는 것과 같은 방식으로 드라이버를 운용하려 하기 때문에 엄격하게는 PNP 드라이버라고 부르는 것이 맞다고 생각되기 때문이다.

윈도우는 PNP 관리자와 Power 관리자를 운영하고 있으며, 이들의 영향력에서 벗어나는 드라이버가 바로 레거시 드라이버라고 볼 수 있다.
레거시 드라이버를 작성하는 개발자는 드라이버 코드 내에서 이와 같이 PNP, Power와 관련된 준비를 전혀 할 필요가 없다는 의미가 된다.

다음은 레거시 드라이버를 작성하는 개발자가 준비해둬야 하는 함수(콜백 함수) 리스트다.

* DriverEntry: 드라이버가 메모리에 상주할 때 호출되는 함수다. 유명한 응용프로그램인 "Hello World"의 입장에서 WinMain() 함수와 그 역할이 비슷하다고 보면 된다.
* DriverUnload: 드라이버가 메모리에 해제될 때 호출되는 콜백 함수다. 이 함수는 선택적이므로 가지지 않을 수도 있다. 이 함수를 선언하지 않으면 드라이버는 메모리에서 해제되지 않는다.
* IRP Dispatch: 외부에서 드라이버로 전달되는 명령어(IO Request Packet, IRP)를 받아들이는 진입점이다. 이곳으로는 열기, 닫기, 읽기, 쓰기 등의 파일 입출력 형식과 유사한 명령어가 전달되며, 드라이버 개발자는 이곳에서 명령어를 신속하게 다뤄야 한다. IRP Dispatch의 'Dispatch'라는 단어가 '신속하게 처리한다'는 의미를 담고 있듯이, 이곳에서 드라이버 개발자는 접수된 명령어의 피라미터 오류를 파악한 뒤, 적절한 명령어로 판단되면 빠른 처리를 보장해야 한다. 여기서 '빠른 처리'는 해당하는 명령어를 가능하면 빠리 완료하라는 의미로 사용되는 것이 아니라, 호출자에게 빨리 리턴하라는 것을 의미한다. 이것은 명령어가 접수만 된 상태로 호출자에게 돌아가는 것이 가능하다(STATUS_PENDING)는 의미가 된다.

### 1.1.3 PNP 드라이버

윈도우가 운영하는 PNP 관리자, Power 관리자와 함께 운용될 드라이버를 의미한다.
따라서 레거시 드라이버가 가지는 모든 콜백 함수 외에 별도의 콜백 함수가 추가로 정의돼야 한다.

다음은 PNP 드라이버를 작성하는 개발자가 준비해둬야 하는 함수 리스트다.

* DriverEntry, DriverUnload, IRP Dispatch: 이 내용은 레거시 드라이버의 경우와 같다.
* AddDevice: 디바이스 스택(발견된 하드웨어를 여러 PNP 드라이버들이 효과적으로 운영하기 위해 만든 자료구조)이 구성되자마자 호출되는 콜백 함수다. 드라이버 개발자는 이곳에서 디바이스 스택에 동참할 자신의 디바이스 오브젝트를 만들어서 디바이스 스택에 올려놓는 역할을 수행한다. DriverEntry 콜백함수는 드라이버가 멤리에 상주한다는 의미이지만, AddDevice 콕백 함수는 드라이버가 관여할 하드웨어가 발견됐다는 의미로 호출된다. 동일한 제조사의 하드웨어 2개를 PC에 연결하는 경우, 하드웨어가 2개라 하더라도 드라이버는 하나만 사용된다. 이런 경우 DrvierEntry 콜백 함수는 한 번 호출되지만 AddDevice 콜백 함수가 두 번 호출된다는 점을 기억하면 어렵지 않게 이해할 수 있다. 여기서 AddDevice 콜백 함수가 호출된 시기는 아직까지 하드웨어에 접근해도 좋다는 허가의 의미가 아니라는 점에 주의해야 한다. 하드웨어에 접근해도 되는 시기를 알려주는 방법은 이어지는 IRP_MJ_PNP 콜백 함수와 IRP_MJ_POWER 콜백 함수에 의해 결정된다.
* IRP_MJ_PNP: PNP 관리자가 전달하는 IRP를 처리하는 콜백 함수를 의미한다. PNP 관리자는 여러 가지 플러그 앤 플레이와 관련된 사건들이 발생할 때마다 이를 IRP에 담아서 드라이버에게 전달한다. 따라서 드라이버 개발자는 이곳에서 IRP에 담겨 있는 구체적인 사건의 의미를 파악해 행동해야 한다. 이런사건들은 2장에서 다룬다.
* IRP_MJ_POWER: POWER 관리자가 전달하는 IRP를 처리하는 콜백 함수를 의미한다. POWER 관리자는 전력공급과 관련된 사건들이 발생할 때마다 이를 IRP에 담아서 드라이버에게 전달한다. 따라서 드라이버 개발자는 이곳에서 IRP에 담겨 있는 구체적인 사건의 의미를 파악해 행동해야 한다. 이것들 또한 2장에서 살펴본다.


## 1.2 개발툴 설치

윈도우 드라이버를 개발하려면 개발툴을 설치해야 한다. 과거 윈도우3.1 시절부터 이와 같은 개발툴은 DDK라는 이름으로 공급돼 왔다. 
현재는 WDK라는 이름으로 바뀌어 공급되고 있다.
WDK 7 버전까지는 컴파일러가 함께 포함돼 배포됐기 때문에 개발자는 손쉽게 WDK가 제공하는 일종의 명령어 창을 열고 그곳에서 드라이버를 빌드할 수 있었지만, 최근 WDK는 컴파일러를 따로 포함하지 않고 있기 때문에 별도의 컴파일 환경을 구축해야 한다.
이것은 비주얼 스튜디오 2017을 함께 설치해야만 드라이버를 빌드할 수 있다는 의미다.
이책을 쓰고 있는 현재 WDK 10까지 배포된 상태다.

그런데, 최근까지도 개발자들 사이에서 비주얼 스튜디오 통합환경 속에서 드라이버 빌드가 잘 되지 않는 상황들에 대해서 이야기가 나오고 있다.
이에 나는 컴파일러와 링커가 모두 내장된 환경인 EWDK(엔터프라이즈 WDK)를 사용해서 드라이버를 빌드할 것이다.
드라이버를 쉽게 빌드할 수 있다는 장점을 가지고 있지만, 빌드에 사용되기 위한 모든 프로젝트는 프로젝트 파일을 가지고 있는 상태여야 한다는 단점이 있다.
이에 나는 실습 예제로 제공하는 모든 예제에 프로젝트 파일을 포함하도록 했다.
독자들은 EWDK를 웹 사이트를 통해 받아서 하드디스크 적당한 곳에 ISO 파일을 복사하고 가상 드라이버로 마운트만 하면 된다.

앞으로 특별한 언급이 없다면, 다음과 같은 방식으로 예제를 빌드할 것이다.

디바이스 드라이버 프로젝트는 EWDK 환경을 사용해서 빌드할 것이다.

응용 프로그램 프로젝트는 독자들이 원하는 개발툴을 사용하면 되지만, 여기서는 비주얼 스튜디오를 사용하도록 하겠다.

### 1.2.1 WDK

아래 표를 보면 WDK 8부터는 윈도우 XP용 드라이버를 빌드할 수 없음을 알 수 있다.
그렇기 때문에 윈도우XP까지 지원하는 드라이버를 빌드해야 하는 경우에는 WDK 7600을 설치해 컴파일해야 한다.

||윈도우XP|윈도우7|윈도우8|윈도우8.1|윈도우10
|--|--|--|--|--|--|
|WDK 7600|O|O|X|X|X|
|WDK 8|X|O|O|O|O|
|WDK 10|X|O|O|O|O|


